# Introduction #

The TorAS source code attempts to be autonomous and unobtrusive, reducing the dependence on the developer to create complex setups and connections with the Tor services.

For this reason, TorAS comes with a number of default settings and pre-configurations intended to start the services automatically. While this will probably be sufficient for most developers, at least initially, it's wortwhile to become familiar with the rudimentary operation of TorAS.

It is assumed that developers using TorAS have some knowledge of ActionScript (creating class instances, calling methods, working with data, etc.)

Additionally, while TorAS provides a simplified way to access the Tor services, developers can gain additional low-level control by issuing direct commands to the Tor control and communication sockets. For more information, refer to the following documents:

https://code.google.com/p/toras/wiki/TorControlProtocol_v1

https://code.google.com/p/toras/wiki/SOCKS5ProtocolSpecification

https://code.google.com/p/toras/wiki/TorProtocolSpecification

# Configuration #

The TorControl class is responsible for connecting to, and controlling a running Tor control connection, and optionally for getting the Tor services binary up and running (which starts a Tor control connection). If you plan to start the Tor binary manually, or if it's already running, you can skip this section entirely.

TorControl configures the Tor services binary by dynamically creating a configuration file (torcc), writing it to the default application storage directory (File.applicationStorageDirectory), and then instructing Tor to load it as part of startup ("_tor.exe -f /AppStorageDirectory/torcc_").

The default contents of this file are stored in the TorControl class in the configData property:

```
public static const configData:XML =<config><![CDATA[# TorAS Dynamic Configuration -- generated by TorControl.as
ControlPort %control_port%
ControlListenAddress %control_ip%
ClientOnly 1
SOCKSListenAddress %socks_ip%:%socks_port%
]]></config>
```

Because this data is stored as XML, it is required to be stored within at least one top-level parent node. Although the name "config" is used for this node, any valid XML node name is acceptable since it's only the contents of this node that are used.

To supply TorControl with a custom configuration file, developers can assign this XML data, in the same format as specified, to the TorControl instance's "config" property, at any time prior to calling "connect".

# Configuration Metatags #

The configuration data currently supports 5 metatags, or special strings, which are replaced by custom (or default) settings that are passed to the TorControl instance. These include:

**%control\_ip%** : The IP address used by the running Tor control services socket for control and status commands. This string will be replaced by the IP specified in the TorControl constructor (or the default control IP "127.0.0.1" if not customized). Although the name "localhost" may work here, it is advisable to use the direct IP instead.

**%control\_port%** : The port used by the running Tor control services socket for control and status commands. This string will be replaced by the port specified in the TorControl constructor (or the default control port 9151 if not customized).

**%socks\_ip%** : The IP address used by the running Tor services socket for sending and receiving network requests (for example, HTTP requests). This string will be replaced by the IP specified in the TorControl constructor (or the default SOCKS IP "127.0.0.1" if not customized). Although the name "localhost" may work here, it is advisable to use the direct IP instead.

**%socks\_port%** : The port used by the running Tor services socket for sending and receiving network requests. This string will be replaced by the IP specified in the TorControl constructor (or the default SOCKS port 1080 if not customized).

**%control\_passhash%** : The hashed password to use for authentication with the Tor control services socket. This optional feature was implemented in [revision 112](https://code.google.com/p/toras/source/detail?r=112) and requires the TorControl class to invoke the Tor binary to produce a hash of the supplied password.

Using all default values and the plain-text control password "TorControlConnectionPassword", the built-in configuration data after metatag parsing and hash generation would look like this:

```
# TorAS Dynamic Configuration -- generated by TorControl.as
ControlPort 9151
ControlListenAddress 127.0.0.1
ClientOnly 1
SOCKSListenAddress 127.0.0.1:1080
HashedControlPassword 16:44A5C7F13F0388226092B1EA793C08A3E8BFEA5351214C4F146094A179
```

Note that the control password is optional but recommended in order to prevent unauthorized connections to the Tor control socket.

It is perfectly valid to hardcode these configuration values as in the above, post-metatag-parse data. However, it is adviseable to keep configuration data dynamic and instead use TorControl instantiation parameters for easier future updates and maintainability.

Many additional starup configuration options are available for use with this configuration data. Please refer to the complete list at:

https://www.torproject.org/docs/tor-manual-dev.html

# Starting the TorAS Control Connection #

As mentioned in a previous section, if you don't plan on using TorControl to launch the Tor services binary from within an AIR application, you will need to launch the Tor binary manually. Be sure to note imporant information such as the control IP, control port, SOCKS5 IP, SOCKS5 port, and control password hash -- these will need to be supplied to TorControl at instantiation.

If you're using TorControl to launch the Tor services binary, ensure that you've created valid config data in the step above first. Take extra care to ensure that vital information such as IPs and ports match between TorControl and the Tor config (especially if using non-dynamic, non-metatag data).

Starting TorControl is a simple process. First you need to create the TorControl instance:

```
var torControl:TorControl=new TorControl();
```

To use non-standard port/IP settings, provide these to the constructor. For exaample, if you're using the control address 127.0.0.1:9050 and the SOCKS5 address 127.0.0.1:8050, you would create the TorControl instance like this:

```
var torControl:TorControl=new TorControl("127.0.0.1", 9050, "127.0.0.1", 8050);
```

If you're using the dynamic config option for the Tor services binary, the next step is to assign the config data to the "config" property of the instance:

```
torControl.config=<config>
ControlPort 9050
...
```

At this point, you can set up listeners to any of the optional TorAS events:

http://code.google.com/p/toras/wiki/TorASEvents

The one event that it is highly recommended that you listen to is "TorControlEvent.ONAUTHENTICATE". This event will be broadcast by TorAS once a connection has been established and authenticated (commands may not be issued until both conditions are true).

If you don't want TorControl to automatically launch the Tor services binary, set the "launchServices" property to _false_ at this point (default is _true_):

```
torControl.launchServices=false;
```

The final step in establishing a connection to the running Tor control services is to call the "connect" method of the TorControl instance:

```
torControl.connect();
```

If properly configured and enabled, this will automate the launch, configuration, and initial connection(s) of the Tor services binary.

The benefit of using TorControl to launch the Tor services binary is that you will also be able to observe STDOUT messages -- the Tor binary equivalent of ActionScript "trace" commands. These messages can be received by listening to the "TorControlEvent.ONLOGMSG" event. If you are launching the Tor services binary manually, this event will never be dispatched.

Putting all of this together, starting up TorControl using default values may look something like this:

```
import org.torproject.TorControl;
import org.torproject.events.TorControlEvent;
var torControl:TorControl=new TorControl();
torControl.addEventListener(TorControlEvent.ONAUTHENTICATE, this.onTorReady);
torControl.connect();
function onTorReady(eventObj:TorControlEvent):void {
   trace ("Tor control connection is authenticated and ready.");
}
```

# Communicating through Tor #

As mentioned in the previous section, it is not necessary to use TorControl to start the Tor service. If you have already started it and have noted the SOCKS IP and port settings, you can communicate through Tor's proxy using a SOCKS5 "tunnel". Because the running Tor process provides both control and communication connections as independent services, TorAS' SOCKS5Tunnel and TorControl are also independent and each can be used without the other.

The SOCKS5Tunnel class creates the SOCKS5 tunnel which the Tor communication channel (circuit) uses to proxy requests. Each request is encrypted and sent through the Tor network until reaching an "exit node" which performs the actual request and response. For all requests, TorAS uses Tor's internal DNS resolution mechanism which adds extra security by not exposing domain lookups.

## HTTP and HTTPS Requests ##

The most common type of request via a SOCKS5Tunnel is the HTTP request, similar to ActionScript's URLLoader class. SOCKS5Tunnel uses the URLRequest class to determine which server to communicate with, what data to include with the request, and other configuration options used to manipulate the request data.

A URLRequest instance is created in in exactly the same way as for a URLLoader instance:

```
import import flash.net.URLRequest;
import import flash.net.URLVariables;

var request:URLRequest=new URLRequest("http://www.myserver.com/");
var variables=new URLVariables();
variables.userName="Patrick";
variables.password="pass123";
request.data=variables;
```

Not all properties or a URLRequest instance are supported by TorAS (yet!) These include:

**authenticate, cacheResponse, contentType, digest, idleTimeout, method (limited support), useCache**

Additionally, the following method is not yet supported:

**useRedirectURL**

HTTPS requests are supported as of [revision 115](https://code.google.com/p/toras/source/detail?r=115) -- simply use "https" instead of "http" as the protocol within the specified URL (all other instructions can stay the same). Be aware, however, that HTTPS has not been fully tested so functionality should currently be considered unstable.

Once the request has been properly constructed, it is used as the parameter for the loadHTTP method of the SOCKS5Tunnel instance:

```
import org.torproject.SOCKS5Tunnel;
import org.torproject.events.SOCKS5TunnelEvent;

var tunnel:SOCK5Tunnel = new SOCKS5Tunnel();
tunnel.addEventListener(SOCKS5TunnelEvent.ONHTTPRESPONSE, onSOCKSTunnelResponse);
tunnel.loadHTTP(request);	

function onSOCKSTunnelResponse(eventObj:SOCKS5TunnelEvent):void {
   if (eventObj.secure==false) {
      trace ("Got HTTP response: ");
   } else {
      trace ("Got HTTPS response: ");
   }
   trace (eventObj.httpResponse.body);
}
```

There are other events that you can listen to, including _SOCKS5TunnelEvent.ONHTTPSTATUS_, which is broadcast as soon as the connection has received enough information to fully parse the HTTP response code (200, 404, etc.), and _SOCKS5TunnelEvent.ONHTTPHEADERS_ which is dispatched when enough HTTP header information has been received. The _SOCKS5TunnelEvent.ONHTTPRESPONSE_ event is the final event dispatched, once the complete response body has been received.

Other than the HTTP response information already mentioned, the HTTP response object also contains a vector array of HTTPCookie objects (containing any valid cookies), which are generated from any "Set-Cookie" directives in the response headers. This data becomes available to developers as soon as response headers are fully received and parsed.

SOCKS5Tunnel attempts to reconstruct chunked HTTP responses so that the contents of the _SOCKS5TunnelEvent.httpResponse.body_ property contains the reconstructed (un-chunked) response data. However, the raw HTTP response, including headers and chunked sections, can be accessed via the _SOCKS5TunnelEvent.httpResponse.rawResponse_ property (a ByteArray).

Putting this all together, a sample HTTP request would look something like this:

```
import import flash.net.URLRequest;
import import flash.net.URLVariables;
import org.torproject.SOCKS5Tunnel;
import org.torproject.events.SOCKS5TunnelEvent;

var request:URLRequest=new URLRequest("http://www.myserver.com/");
var variables=new URLVariables();
variables.userName="Patrick";
variables.password="pass123";
request.data=variables;
var tunnel:SOCK5Tunnel = new SOCKS5Tunnel();
tunnel.addEventListener(SOCKS5TunnelEvent.ONHTTPRESPONSE, onSOCKSTunnelResponse);
tunnel.loadHTTP(request);	

function onSOCKSTunnelResponse(eventObj:SOCKS5TunnelEvent):void {
   trace ("Got response: ");
   trace (eventObj.httpResponse.body);
}
```

Additional events are provided by the SOCKS5Tunnel class that you can include for greater control and insight: http://code.google.com/p/toras/wiki/TorASEvents